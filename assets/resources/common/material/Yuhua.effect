//羽化效果

%{
	techniques: [
		{
			passes: [
				{
					vert: vs
					frag: fs
					cullMode: none
					blend: true
				}
			]
			layer: 0
		}
	]
	properties: {
		
	}
%}

%% vs {

precision highp float;

uniform mat4 cc_matViewProj;
attribute vec3 a_position;
attribute vec2 a_uv0;
attribute vec4 a_color;
varying mediump vec2 v_uv0;
varying lowp vec4 v_fragmentColor;

void main () {
	gl_Position = cc_matViewProj * vec4(a_position, 1);
	v_fragmentColor = a_color;
	v_uv0 = a_uv0;
}

}

%% fs {

precision highp float;

varying vec4 v_fragmentColor;
varying vec2 v_uv0;

uniform sampler2D texture;
//uniform vec3 u_outlineColor;
//uniform float u_threshold;
//uniform float u_radius;

vec4 composite(vec4 over, vec4 under)
{
	return over + (1.0 - over.a) * under;
}

void main () {
	/*
	vec2 shadowOffset = vec2(-0.03, -0.03);
	vec4 textureColor = texture2D(texture, v_uv0);
	#if _USE_ETC1_TEXTURE
		textureColor.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;
	#endif
	float shadowMask = texture2D(texture, v_uv0 + shadowOffset).a;
	const float shadowAlpha = 0.5;
	vec4 shadowColor = vec4(0, 0, 0, shadowMask * shadowAlpha );
	gl_FragColor = composite(textureColor , shadowColor);
	*/

	float u_radius = 0.02;
	float u_threshold = 1.0;
	vec3 u_outlineColor = vec3(0.8,0.8,0.8);

	float radius = u_radius;
    vec4 accum = vec4(0.0);
    vec4 normal = vec4(0.0);
    
    normal = texture2D(texture, vec2(v_uv0.x, v_uv0.y));
    
    accum += texture2D(texture, vec2(v_uv0.x - radius, v_uv0.y - radius));
    accum += texture2D(texture, vec2(v_uv0.x + radius, v_uv0.y - radius));
    accum += texture2D(texture, vec2(v_uv0.x + radius, v_uv0.y + radius));
    accum += texture2D(texture, vec2(v_uv0.x - radius, v_uv0.y + radius));
    
    accum *= u_threshold;
    accum.rgb =  u_outlineColor * accum.a;
    accum.a = 1.0;
    
    normal = ( accum * (1.0 - normal.a)) + (normal * normal.a);
    
    gl_FragColor = v_fragmentColor * normal;
}

}
